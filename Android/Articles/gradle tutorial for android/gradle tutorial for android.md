# Gradle Tutorial for Android

## What is Gradle?

Gradle is an open source build automation system. With Gradle, you can easily manipulate the build process and its logic to create multiple versions of your app

## Getting Started

Pay attention to the files with the green Gradle icon and *.gradle* extension in the project structure view. These files are generated by Android Studio automatically during project creation. They are responsible for the processing of your project’s build. They contain the necessary info about the project structure, library dependencies, library versions, and the app versions you’ll get as a result of the build process.

### Project-level build.gradle

It’s called a top-level (project-level) build.gradle file. It contains the settings which are applied to all modules of the project.

```groovy
//1
buildscript {
    ext {
        compose_ui_version = '1.2.0'
    }
}// Top-level build file where you can add configuration options common to all sub-projects/modules.
//2
plugins {
    id 'com.android.application' version '7.4.0' apply false
    id 'com.android.library' version '7.4.0' apply false
    id 'org.jetbrains.kotlin.android' version '1.7.0' apply false
}
```

1. n the `buildscript` block you define settings needed to perform your project building.

2. The `plugins` block contains necessary plugin dependencies, in this case the Gradle and Kotlin plugins. Do not put your module dependencies in this block.

### Module-level build.gradle

Now go to the *build.gradle* file in the *app* module directory. It contains dependencies (libraries which a module relies on), and instructions for the build process. Each module defines its own *build.gradle* file.

```groovy
// 1
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

// 2
android {
    // 3
    compileSdkVersion 27
    // 4
    defaultConfig {
        // 5
        applicationId "com.raywenderlich.socializify"

        minSdkVersion 21
        // 6
        targetSdkVersion 27
        // 7
        versionCode 1
        // 8
        versionName "1.0"
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'org.jetbrains.kotlin:kotlin-stdlib-jre7:1.1.51'
    implementation 'com.android.support:appcompat-v7:27.0.1'
    implementation 'com.android.support.constraint:constraint-layout:1.0.2'
}
```

1. Specifies a list of plugins needed to build the module. The `com.android.application` plugin is necessary in order to setup the Android-specific settings of the build process. Here you can also use `com.android.library` if you’re creating a library module. The `kotlin-android` plugin allow you to use the Kotlin language .

2. In the `android` block you place all platform-specific options of the module.

3. The `compileSdkVersion` option indicates the API level your app will be compiled with. In other words, you cannot use features from an API higher than this value.

4. The `defaultConfig` block contains options which will be applied to all build versions (e.g., debug, release, etc) of your app by default.

5. The `applicationId` is the identifier of your app. It should be unique so as to successfully publish or update your app on Google Play Store.

6. The `targetSdkVersion` parameter defines the maximum API level your app has beeen tested on. That is to say, you’re sure your app works properly on the devices with this SDK version, and it doesn’t require any backward compatibility behaviors. The best approach is to thoroughly test an app using the latest API, keeping your `targetSdkVersion` value equal to `compileSdkVersion`.

7. `versionCode` is a numeric value for the app version.

8. `versionName` is a user-friendly string for the app version.

### Finally, settings.gradle

In this file, you should define all of your project’s modules by name. Here we have only one module – *app*. In a large, multi-module project, this file can have a much longer list.

```groovy
include ':app'
```

## Groovy vs. Kotlin in Gradle

You may be wondering, why would you use Kotlin for writing Gradle scripts?

First of all, Kotlin is a statically typed language (Groovy is dynamically typed), which allows for conveniences like *autocompletion*, *better refactoring tools* and *source-code navigation*. You can work in script files just you would with Kotlin classes, with all support of Android Studio you’re used to. Moreover, autocompletion will prevent you from making typos :].

Secondly, it’s practical to work with a single language across your app and your build system.

### What is gradlew

*gradlew* is the *Gradle Wrapper*. You don’t need to worry about installating Gradle on your computer – the wrapper will do that for you. Even more, it’ll allow you to have different projects built with various versions of Gradle.

### gradlew tasks

execute the following command:

> ./gradlew tasks

You’ll see a list containing all available tasks...

### gradlew assemble

Run this comment:

> ./gradlew assemble

```bash
> Task :app:compileDebugKotlin
Using kotlin incremental compilation

> Task :app:compileReleaseKotlin
Using kotlin incremental compilation


BUILD SUCCESSFUL in 29s
52 actionable tasks: 52 executed
```

From the output, it’s apparent that Gradle compiled two versions of the app – *debug* and *release*.  
Verify this by changing to the build output directory:

`cd app/build/outputs/apk/`

To review the contents of a directory run the following command:

`ls -R`

### gradlew lint

Run the following command:

> ./gradlew lint

The `lint` command, and any commands which start with *‘lint’*, analyzes the whole project looking for various mistakes, typos or vulnerabilities.

### Build Types

By default, there are two build types – *debug* and *release*. The only difference between them is the value of the `debuggable` parameter. In other words, you can use the debug version to review logs and to debug the app, while the release one is used to publish your app to the *Google Play Store*. You can configure properties to the build types by adding the following code in the `android` block of your module-level *build.gradle* file:

```groovy
buildTypes {
    release {

    }
    debug {

    }
}
```

### Build Signing

One of the most important configurations of the build is its signature. Without a signature, you’ll be unable to publish your application, since it’s necessary to verify you as an owner of the specific application. While you don’t need to sign the debug build – Android Studio does it automatically – the release build should be signed by a developer.

When your keystore is ready, add the code below in the `android` block and *above the `buildTypes` block* (the order of declaration matters) of the module-level *build.gradle* file:

```groovy
signingConfigs {
    release {
        storeFile file("path to your keystore file")
        storePassword "your store password"
        keyAlias "your key alias"
        keyPassword "your key password"
    }
}
```

*Note:* There are two important considerations related to your keystore file:

1. Once you’ve published your app to the Google Play Store, subsequent submissions must use the same keystore file and password, so keep them safe.
2. Be sure NOT to commit your keystore passwords to a version control system such as GitHub. You can do so by keeping the password in a separate file from `build.gradle`, say `keystorePassword.gradle` in a `Signing` directory, and then referencing the file from the app module-level `build.gradle`

### Build Flavors

In order to create multiple versions of your app, you need to use *product flavors*. Flavors are a way to differentiate the properties of an app, whether it’s free/paid, staging/production, etc.

```groovy
// 1
flavorDimensions "appMode"
// 2
productFlavors {
    // 3
    free {
        // 4
        dimension "appMode"
        // 5
        applicationIdSuffix ".free"
        // 6
        manifestPlaceholders = [appName: "@string/app_name_free"]
    }
    paid {
        dimension "appMode"
        applicationIdSuffix ".paid"
        manifestPlaceholders = [appName: "@string/app_name_paid"]
    }
}
```

1. You need to specify the flavor dimensions to properly match the build types. In this case, you need only one dimension – the app mode.
2. In the `productFlavors` specify a list of flavors and their settings. In this case, `free`, and `paid`
3. Specify the name of the first product flavor – `free`.
4. It’s mandatory to specify the `dimension` parameter value. The `free` flavor belongs to the `appMode` dimension.
5. Since you want to create separate apps for free and paid functionality, you need them to have different app identifiers. The `applicationIdSuffix` parameter defines a string that’ll be appended to the `applicationId` giving your app unique identifiers.
6. The `manifestPlaceholders` allows you to modify properties in your *AndroidManifest.xml* file at build time. In this case, modify the application name depending on its version.

### What is a Build Variant

From the output above, what you’ve actually generated are different *build variants*, which are a combination of build types – *debug* and *release* and build flavors – *free* and *paid*. That is to say, you have four possible build variants – *paidDebug*, *paidRelease*, *freeDebug* and *freeRelease*.

Declare a constant for the *paid* flavor right below the declaration of `ProfileActivity` class:

```kotlin
companion object {
  const val PAID_FLAVOR = "paid"
}
```

Add the following function to `ProfileActivity`:

```kotlin
private fun isAppPaid() = BuildConfig.FLAVOR == PAID_FLAVOR
```

You can now check if a user is using a paid version of the app. Depending on the result of this check, you’ll enable or disable some functionality visible to your user so they can clearly see what version they’re using in-app.

## Creating Tasks

Sometimes you need your build system to do something more complicated or customize the build process in some way. For example, you may want Gradle to output an APK file containing the build date in its name. One possible solution to this is to create a custom Gradle task.

Add the following code in your module-level *build.gradle* file at the same level as `android` block:

```groovy
// 1
task addCurrentDate() {
    // 2
    android.applicationVariants.all { variant ->
        // 3
        variant.outputs.all { output ->
            // 4
            def date = new Date().format("dd-MM-yyyy")
            // 5
            def fileName = variant.name + "_" + date + ".apk"
            // 6
            output.outputFileName = fileName
        }
    }
}
```

Here’s what’s is going on:

1. You define an `addCurrentDate()` task.
2. You iterate through all the output build variants.
3. You iterate over all the APK files.
4. You create an instance of `Date` and format it.
5. You create a new filename appending the current date to the initial name.
6. You set the new filename to current APK file.

Now you need to execute this task at a specific point of the build process. Add the following code below the `task addCurrentDate()` block:

```groovy
gradle.taskGraph.whenReady {
    addCurrentDate
}
```

The task specified in the `whenReady` block will be called once when the current graph is filled with tasks and ready to start executing them. Here, you specify the name of your `addCurrentDate` task.

## Creating Custom Plugins

Usually it’s a good idea to factor out your code into smaller pieces so it can be reused. Similarly, you can factor out your tasks into a custom behavior for the building process as a plugin. This will allow you to reuse the same behavior in other modules you may add to your project.

To create a plugin, add the following class below the `addCurrentDate` task in the module-level *build.gradle* file:

```groovy
class DatePlugin implements Plugin<Project> {
    void apply(Project project) {
        project.task('addCurrentDatePluginTask') {
            project.android.applicationVariants.all { variant ->
                variant.outputs.all { output ->
                    def date = new Date().format("dd-MM-yyyy")
                    def fileName = variant.name + "_" + date + ".apk"
                    output.outputFileName = fileName
                }
            }
        }
    }
}
```

Add the name of your plugin at the top of this file along with the other `apply plugin` definitions:

`apply plugin: DatePlugin`

Conceptually, the code in the plugin is doing the same thing as the task – you’re still modifying the names of the output files. The only difference is that you define a class which implements `Plugin` and its single method `apply(Project project)`.

In this method, you’re adding your plugin to the target – `Project`. By calling the `task(String name, Closure configureClosure)` method you’re creating a new task with a specific name and behavior and adding it to the project.

Now modify the `whenReady` block to call a new task:

```groovy
gradle.taskGraph.whenReady {
    addCurrentDatePluginTask
}
```

## Reference

[gradle tutorial for android]([Gradle Tutorial for Android: Getting Started | Kodeco](https://www.kodeco.com/249-gradle-tutorial-for-android-getting-started#toc-anchor-021))
